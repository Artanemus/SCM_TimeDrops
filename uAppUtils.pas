unit uAppUtils;

interface

uses dmAppData, vcl.ComCtrls, Math, System.Types, System.IOUtils,
  Windows, System.Classes, SCMDefines, System.StrUtils, SysUtils ;

function StripAlphaChars(const InputStr: string): string;

type
  TAppUtils = record
  private
    type
      PTime = ^TTime;
    var
      fSplits: array[0..9] of double;
      fTimeKeepers: array[0..2] of double;
      fPrecedence: dtPrecedence;
      fSList: TStringList; // Header, Body(multi-line ... lanes) and Footer.
      fFileType: dtFileType; // dtUnknow,dtDO3, dtDO4
      fFileName: string; // Filename + EXTENSION. NO PATH.
      fCreatedDT: TDateTime;
      fAcceptedDeviation: double;
      fCalcMode: integer; // 0 = DT Method. (Default) 1 = SCM Method.

    // --------------------------------------------
    { Routine to :
      - Extract Filename+Ext to dtUtils.fFileName. (EXCLUDES PATH)
      - load dtUtils.fStrList with TFilename.
      - store dtUtils.fFileType with dtFileType.
     }
    function PrepareExtraction(const AFileName: TFileName): boolean;
    // After prepare the following routines can be called.
    // --------------------------------------------
    { TStringList - HEADER}
//    function sListHeaderSessionNum(): integer;
//    function sListHeaderEventNum(): integer;
//    function sListHeaderHeatNum(): integer;
//    function sListHeaderGenderChar(): char;
    { TStringList - BODY - ref: fSListIndex }
//    function sListBodyLane(LineIndex: integer): integer;
//    function sListBodyTimeKeepers(LineIndex: integer; var ATimeKeepers: array of double): boolean;
//    function sListBodySplits(LineIndex: integer; var ASplits: array of double): boolean;
    { TStringList - FOOTER }
//    function sListFooterHashStr(): string;
    { FILENAME EXTRACTION ROUTINES...}
//    function fn_SessionNum(): integer;
//    function fn_EventNum(): integer;
//    function fn_HeatNum(): integer;
//    function fn_RoundChar(): char;
//    function fn_HashStr(): string;
//    function fn_RaceID(): integer;

    // --------------------------------------------

//    function TryParseCustomTime(const s: string; out ATimeValue: TDateTime): boolean;
    function ConvertSecondsStrToTime(ASecondsStr: string): TTime;

  public
    // Sub-routines for Process
    procedure PrepareTDData();
    procedure PopulateTDData(const ADirectory: string; pBar: TProgressBar);
    procedure AppendTDData(const AFileName: string);
    // procedure CalculateDeviation(EntrantID: integer; AEventType: scmEventType);

    function DirHasResultFiles(const ADirectory: string): boolean;
    function GetDTFileTypeOfFile(const AFileName: string): dtFileType;

    class operator Initialize(out Dest: TAppUtils);
    class operator Finalize(var Dest: TAppUtils);

    property AcceptedDeviation: double read FAcceptedDeviation write FAcceptedDeviation;

  end;


// ---------------------------------------------------

{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}

implementation

uses System.Character, DateUtils, Data.DB, tdResults;

function StripAlphaChars(const InputStr: string): string;
var
  Achar: Char;
begin
  Result := '';
  for Achar in InputStr do
    if Achar.IsDigit then
      Result := Result + Achar;
end;

function TAppUtils.ConvertSecondsStrToTime(ASecondsStr: string): TTime;
var
  TotalSeconds: Double;
  Hours, Minutes, Seconds, Milliseconds: Word;
begin
  Result := 0; // Initialize the result to zero

  // Check if the input string is empty
  if Trim(ASecondsStr) = '' then
    Exit;

  // Attempt to convert the string to a floating point value
  try
    TotalSeconds := StrToFloat(ASecondsStr);
  except
    // If an error occurs, return zero
    Exit;
  end;

  // Calculate the hours, minutes, seconds, and milliseconds components
  Hours := Trunc(TotalSeconds) div 3600;
  TotalSeconds := TotalSeconds - (Hours * 3600);
  Minutes := Trunc(TotalSeconds) div 60;
  TotalSeconds := TotalSeconds - (Minutes * 60);
  Seconds := Trunc(TotalSeconds);
  Milliseconds := Round(Frac(TotalSeconds) * 1000);

  // Encode the components back into a TTime value
  Result := EncodeTime(Hours, Minutes, Seconds, Milliseconds);
end;

class operator TAppUtils.Finalize(var Dest: TAppUtils);
begin
  FreeAndNil(Dest.fSList);
  Dest.fFileType := dtUnknown;
end;

class operator TAppUtils.Initialize(out Dest: TAppUtils);
begin
  Dest.fSList := TStringList.Create;
  Dest.fFileType := dtUnknown;
  Dest.fFileName := '';
  Dest.fCalcMode := 0;
end;

function TAppUtils.DirHasResultFiles(const ADirectory: string): boolean;
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I: Integer;
begin
  fileMask := '*.JSON';
  result := false;
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    // TEST for Dolphin Timing files.
    if (Length(LList) > 0) then
    begin
      result := true;
      exit;
    end;
    for I := LOW(LList) to HIGH(LList) do
    begin
      if LList[I].Contains('Session') then
      begin
        result := true;
        exit;
      end;
    end;

  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Get file type of directory...'), MB_ICONERROR or MB_OK);
    exit;
  end;
end;

function TAppUtils.GetDTFileTypeOfFile(const AFileName: string): dtFileType;
begin
  result := dtUnknown;
  if AfileName.Contains('.DO3') then
    result := dtDO3
  else if AfileName.Contains('.DO4') then
    result := dtDO4;
end;

(*
function TAppUtils.fn_SessionNum: integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  if fFileName.IsEmpty() then exit;
  // Split string by the '-' character
  Fields := SplitString(fFileName, '-');
  if Length(Fields) > 0 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[0], 0);
end;

function TAppUtils.fn_EventNum(): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  if fFileName.IsEmpty then exit;
  // Split string by the '-' character
  // example of fFileName
  // - 088-001-001A-0001.do4
  // - 088-000-00F0147.do3
  Fields := SplitString(fFileName, '-');
  if Length(Fields) > 1 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[1], 0);
end;

function TAppUtils.fn_HeatNum(): integer;
var
  Fields: TArray<string>;
  HeatNumStr: string;
begin
  result := 0;
  if fFileName.IsEmpty then exit;
  // only Dolphin Timing v4 Files have 'Heat Number' information in FileName.
  if (fFileType <> dtDO4) then exit;
  // example of fFileName
  // - 088-001-001A-0001.do4
  // - 088-000-00F0147.do3
  // Split string by the '-' character
  Fields := SplitString(fFileName, '-');
  if Length(Fields) > 2 then
  begin
    // remove the 'Round' character ['A', 'P', 'F'].
    HeatNumStr := StripAlphaChars(Fields[2]);
    // Extract the first field - SessionID
    result := StrToIntDef(HeatNumStr, 0);
  end;
end;

function TAppUtils.fn_HashStr(): string;
var
  HashStr: string;
  Fields: TArray<string>;
begin
  result := '';
  HashStr := '';
  if fFileName.IsEmpty then exit;
  // Split string by the '-' character
  // example of fFileName
  // - 088-001-001A-0001.do4
  // - 088-000-00F0147.do3
  Fields := SplitString(fFileName, '-');
  case fFileType of
    dtUnknown: ;
    dtDO4:
      begin
        if Length(Fields) > 3 then
        begin
          // The fourthfield has a '.' delimiter for the string and the '.do4' part
          HashStr := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
        end;
      end;
    dtDO3:
      begin
        if Length(Fields) > 2 then
        begin
          // The third field has a '.' delimiter for the string and the '.do3' part
          HashStr := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);
        end;
      end;
    dtALL: ;
  end;
  if Length(HashStr) > 0 then
    // only 8 character permitted.
    result := Copy(HashStr, 1, 8);
end;

function TAppUtils.fn_RaceID(): integer;
var
  RaceStr: string;
  Fields: TArray<string>;
begin
  result := 0;
  RaceStr := '';
  if fFileName.IsEmpty then exit;
  if (fFileType <> dtDO4) then exit;
  // Split string by the '-' character
  // example of fFileName
  // - 088-001-001A-0001.do4
  Fields := SplitString(fFileName, '-');
  if Length(Fields) > 3 then
  begin
    // The fourthfield has a '.' delimiter for the string and the '.do4' part
    RaceStr := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
    if Length(RaceStr) > 0 then
      // only 8 character permitted.
      result := StrToIntDef(RaceStr, 0);
  end;
end;

function TAppUtils.fn_RoundChar(): char;
var
  RoundChar: char;
  Fields: TArray<string>;
begin
  result := 'A'; // Safe to assign: DEFAULT.
  if fFileName.IsEmpty then exit;
  // only Dolphin Timing v4 Files have 'Heat Number' information in FileName.
  if (fFileType <> dtDO4) then exit;
  // Split string by the '-' character
  // example of fFileName - 088-001-001A-0001.do4
  // The letter A in the above example, indicates the 'Round Type'
  // Round – “A” for all, “P” for prelim or “F” for final.
  Fields := SplitString(fFileName, '-');
  if Length(Fields) > 2 then // Correct condition
  begin
    RoundChar := Fields[2][Length(Fields[2])]; // Get the last character of Fields[2]
    // Convert to uppercase before checking
    RoundChar := UpCase(RoundChar);
    // Round – “A” for all, “P” for prelim or “F” for final.
    if CharInSet(RoundChar, ['A', 'P', 'F']) then
      result := RoundChar;
  end;
end;
*)

procedure TAppUtils.AppendTDData(const AFileName:string);
Begin
  ProcessFile(AFileName);
End;

function TAppUtils.PrepareExtraction(const AFileName: TFileName): boolean;
begin
  { Called by ProcessSession for each TFileName. Initialises private fields.
    These paramas are then used later by fn_ and sList functions. }
  result := false;
  if not Assigned(fSList) then exit;
  fSList.Clear;
  if FileExists(AFileName) then
  begin
    fFileName := ExtractFileName(AFileName);
      // Time stamp of file. Created On DateTime.
    fCreatedDT :=TFile.GetCreationTime(AFileName);
    fSList.LoadFromFile(AFilename);
    fFileType := GetDTFileTypeOfFile(fFileName);;
    result := true;
  end
  else
  begin
    fFileName := '';
    fSList.Clear;
    fFileType := dtUnKNown;
  end;
end;

procedure TAppUtils.PrepareTDData();
begin
  fPrecedence := dtPrecHeader; // (sListHeaderSessionNum)

  // clear all data records ....
  AppData.tblmSession.EmptyDataSet;
  AppData.tblmEvent.EmptyDataSet;
  AppData.tblmHeat.EmptyDataSet;
  AppData.tblmLane.EmptyDataSet;
  AppData.tblmNoodle.EmptyDataSet;

  // re-establish Master Detail ...
  AppData.tblmEvent.MasterSource := AppData.dsmSession;
  AppData.tblmEvent.MasterFields := 'SessionID';
  AppData.tblmEvent.DetailFields := 'SessionID';
  AppData.tblmEvent.IndexFieldNames := 'SessionID';

  AppData.tblmHeat.MasterSource := AppData.dsmEvent;
  AppData.tblmHeat.MasterFields := 'EventID';
  AppData.tblmHeat.DetailFields := 'EventID';
  AppData.tblmHeat.IndexFieldNames := 'EventID';

  AppData.tblmLane.MasterSource := AppData.dsmHeat;
  AppData.tblmLane.MasterFields := 'HeatID';
  AppData.tblmLane.DetailFields := 'HeatID';
  AppData.tblmLane.IndexFieldNames := 'HeatID';

  AppData.tblmNoodle.MasterSource := AppData.dsmHeat;
  AppData.tblmNoodle.MasterFields := 'HeatID';
  AppData.tblmNoodle.DetailFields := 'HeatID';
  AppData.tblmNoodle.IndexFieldNames := 'HeatID';

end;

Procedure TAppUtils.PopulateTDData(const ADirectory: string; pBar: TProgressBar);
begin
  AppData.tblmSession.DisableControls;
  AppData.tblmEvent.DisableControls;
  AppData.tblmHeat.DisableControls;
  AppData.tblmLane.DisableControls;
  AppData.tblmNoodle.DisableControls;

  if Assigned(pBar) then pBar.Position := 0;

  // NOTE: ProcessDirectory will disabled/enabled Master-Detail.
  // Necessary to calculate table Primary keys, etc.
  ProcessDirectory(ADirectory);

  AppData.tblmSession.First;
  AppData.tblmEvent.ApplyMaster;
  AppData.tblmEvent.First;
  AppData.tblmHeat.ApplyMaster;
  AppData.tblmHeat.First;

  AppData.tblmSession.EnableControls;
  AppData.tblmEvent.EnableControls;
  AppData.tblmHeat.EnableControls;
  AppData.tblmLane.EnableControls;
  AppData.tblmNoodle.EnableControls;

  end;

(*
function TAppUtils.sListHeaderEventNum: integer;
var
  Fields: TArray<string>;
begin
  {first line : SessionNum;EventNum;HeatNum;gender (A,B,X) }
  result := 0;
  if not fSList.IsEmpty then
  begin
    Fields := SplitString(fSList[0], ';');
    if Length(Fields) > 1 then
      result := StrToIntDef(Fields[1], 0);
  end;
end;

function TAppUtils.sListHeaderGenderChar(): char;
var
  Fields: TArray<string>;
  GenderChar: char;
begin
  {first line : SessionNum;EventNum;HeatNum;gender (A,B,X) }
  result := #0;
  if not fSList.IsEmpty then
  begin
    Fields := SplitString(fSList[0], ';');
    if Length(Fields) > 3 then
    begin
      GenderChar := Fields[3].Chars[0];
      if CharInSet(GenderChar, ['A', 'B', 'X']) then
      begin
        result := UpperCase(GenderChar)[1]; // Convert to upper case if necessary
      end;
    end;
  end;
end;

function TAppUtils.sListHeaderHeatNum(): integer;
var
  Fields: TArray<string>;
begin
  {first line : SessionNum;EventNum;HeatNum;gender (A,B,X) }
  result := 0;
  if not fSList.IsEmpty then
  begin
    Fields := SplitString(fSList[0], ';');
    if Length(Fields) > 2 then
      result := StrToIntDef(Fields[2], 0);
  end;
end;

function TAppUtils.sListFooterHashStr(): string;
var
  HashStr: string;
begin
  {last line of TStringList : 16 bit HASH number.}
  result := '';
  if fSList.IsEmpty then exit;
  // last line of StringList
  HashStr := fSList[fSList.Count - 1];
  // Quick hack to assert hash string.
  // All preceeding lines in StringList contain character(s) ';'.
  if not ContainsText(HashStr, ';') then
  begin
    HashStr := Copy(HashStr,1, 16); // max 16 chars
    result := HashStr;
  end;
end;

function TAppUtils.sListHeaderSessionNum(): integer;
var
  Fields: TArray<string>;
begin
  {first line : SessionNum;EventNum;HeatNum;gender (A,B,X) }
  result := 0;
  if not fSList.IsEmpty then
  begin
    Fields := SplitString(fSList[0], ';');
    if Length(Fields) > 0 then
      result := StrToIntDef(Fields[0], 0);
  end;
end;

*)

{
function TAppUtils.TryParseCustomTime(const s: string; out ATimeValue: TDateTime): boolean;
var
  Minutes, Seconds, Milliseconds: word;
  TimeParts: TArray<string>;
begin
  Result := False;
  ATimeValue := 0;
  Minutes := 0;
  Seconds := 0;
  Milliseconds := 0;
  ATimeValue := 0;

  if length(s) = 0 then exit;

  // Check if the string contains ':'
  if Pos(':', s) > 0 then
  begin
    // Split the string by the ':'
    TimeParts := SplitString(s, ':');
    if Length(TimeParts) = 2 then
    begin
      // Convert the minute part
      Minutes := StrToIntDef(TimeParts[0], -1);
      // Further split the seconds and optional milliseconds part by the '.'
      TimeParts := SplitString(TimeParts[1], '.');
      if Length(TimeParts) = 2 then
      begin
        // Convert the parts to integer values using StrToIntDef
        Seconds := StrToIntDef(TimeParts[0], -1);
        Milliseconds := StrToIntDef(TimeParts[1], -1);
      end
      else
      begin
        // Only seconds part
        Seconds := StrToIntDef(TimeParts[0], -1);
      end;
    end;
  end
  else
  begin
    // Split the string by the '.'
    TimeParts := SplitString(s, '.');
    if Length(TimeParts) = 2 then
    begin
      // Convert the parts to integer values using StrToIntDef
      Seconds := StrToIntDef(TimeParts[0], -1);
      Milliseconds := StrToIntDef(TimeParts[1], -1);
    end
    else
    begin
      // Only seconds part
      Seconds := StrToIntDef(s, -1);
    end;
  end;

  // Validation not required.
  // Create the TDateTime value
  ATimeValue := EncodeTime(0, Minutes, Seconds, Milliseconds);
  Result := True;
end;
}
(*
function TAppUtils.sListBodySplits(LineIndex: integer; var ASplits: array of double): boolean;
var
  Fields: TArray<string>;
  i, SplitIndex: Integer;
  s: string;
  Found: boolean;
  ATimeValue: TDateTime;
begin
  {
    Number of Splits – (1-10) Enter 1 to use the first time as the final time.
    A single length race would have only one split (i.e. the final time), and
    multi length races would have one split for every lap.

    Example 1: A 25 yard race in a 25 yard pool would have a split count of 1
    meaning only on one time is collected (i.e. the final time)

    Example 2: A 100 meter race in a 50 meter pool would also have a split count
    of 1 (i.e: the final time of the single lap.)

    Example 3: A 200 yard race in a 25 yard pool would have a split count of 4.
  }

  Result := False;
  Found := False;

  // Initialize splits - zero indicates no race time recorded.
  for i := Low(ASplits) to High(ASplits) do
    ASplits[i] := 0;

  // Only DO4 captures split data
  if fFileType <> dtDO4 then
    Exit;

  // Using LineIndex, get the TStringList[...] string and split it by the ';' character
  Fields := SplitString(fSList[LineIndex], ';');

  // Check if there are splits available (Fields[4] and beyond are split-times)
  if Length(Fields) <= 4 then
    Exit; // NO SPLITS..

  // Extract split data
  for i := 4 to Length(Fields) - 1 do
  begin
    s := Fields[i];
    if s <> '' then
    begin
      // Try to parse the time
      ATimeValue := ConvertSecondsStrToTime(s);
      if ATimeValue > 0 then
      begin
        // Calculate the ASplit index
        SplitIndex := i - 4;
        // Ensure index is within bounds
        if (SplitIndex >= Low(ASplits)) and (SplitIndex <= High(ASplits)) then
        begin
          ASplits[SplitIndex] := ATimeValue;
          Found := True;
        end;
      end;
    end;
  end;

  if Found then
    Result := True;
end;

function TAppUtils.sListBodyLane(LineIndex: integer): integer;
var
  Fields: TArray<string>;
  s: string;
begin
  result := 0;
  // Split string by the ';' character
  Fields := SplitString(fSList[LineIndex], ';');
  if Length(Fields) = 0 then exit;   // Input string is empty - err.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'
  s := StripAlphaChars(Fields[0]);
  if Length(s) > 0 then
    result := StrToIntDef(s, 0); // Extract the lane as an integer
end;

function TAppUtils.sListBodyTimeKeepers(LineIndex: integer; var ATimeKeepers:
  array of double): boolean;
var
  Fields: TArray<string>;
  i: integer;
  ATimeValue: TDateTime;
  s: string;
  Found: boolean;
  //  Hour, Min, Sec, MSec: word;
begin
  // Note: Dolphin Timing allows for three timekeepers.
  // Fields[0] = lane number.
  // Fields[1], Fields[2], Fields[3] - TimeKeepers data in DTTime format.
  // examples.  DO4 - 'Lane1;55.98;;' ...  DO3 - '1;95.25;;'
  result := false;
  Found := false;

  // Using LineIndex, get the TStringList[...] string.
  // Split string by the ';' character
  s := fSList[LineIndex];
  Fields := SplitString(fSList[LineIndex], ';');
  // Initialize timekeepers - zero indicates no race time recorded
  for I := Low(ATimeKeepers) to High(ATimeKeepers) do
    ATimeKeepers[I] := 0;
  // Extract timekeepers data.
  // Fields[4] and beyond are split-times.
  for I := 1 to 3 do
  begin
    if Length(Fields) > I then
    begin
      s := Fields[I];
      if s <> '' then
      begin
        // Try to parse the time
        ATimeValue := ConvertSecondsStrToTime(s);
        if ATimeValue > 0 then
        begin
          ATimeKeepers[I - 1] := ATimeValue;
          Found := true;
        end;
      end
    end;
  end;
  if Found then
    result := true;
end;
*)


end.

